'\nImplementing PercentileDiscretizer Layer\n'
_A=None
import libtwml,numpy as np,tensorflow.compat.v1 as tf,twml
from twml.layers import Layer
class PercentileDiscretizer(Layer):
	'\n  PercentileDiscretizer layer is constructed by PercentileDiscretizerCalibrator after\n  accumulating data and performing percentile bucket calibration.\n\n  PercentileDiscretizer takes sparse continuous features and converts then to sparse\n  binary features. Each binary output feature is associated to an PercentileDiscretizer bin.\n  Each PercentileDiscretizer input feature is converted to n_bin bins.\n  Each PercentileDiscretizer calibration tries to find bin delimiters such\n  that the number of features values per bin is roughly equal (for\n  each given PercentileDiscretizer feature). In other words, bins are calibrated to be approx.\n  equiprobable, according to the given calibration data.\n  Note that if an input feature is rarely used, so will its associated output bin/features.\n  '
	def __init__(A,n_feature,n_bin,out_bits,bin_values=_A,hash_keys=_A,hash_values=_A,bin_ids=_A,feature_offsets=_A,num_parts=1,cost_per_unit=100,**K):
		'\n    Creates a non-initialized `PercentileDiscretizer` object.\n    Before using the table you will have to initialize it. After initialization\n    the table will be immutable.\n\n    If there are no calibrated features, then the discretizer will only apply\n    twml.util.limit_bits to the the feature keys (aka "feature_ids"). Essentially,\n    the discretizer will be a "no-operation", other than obeying `out_bits`\n\n    Parent class args:\n      see [tf.layers.Layer](https://www.tensorflow.org/api_docs/python/tf/layers/Layer)\n      for documentation of parent class arguments.\n\n    Required args:\n      n_feature:\n        number of unique features accumulated during PercentileDiscretizer calibration.\n        This is the number of features in the hash map.\n        Used to initialize bin_values, hash_keys, hash_values,\n        bin_ids, bin_values and feature_offsets.\n      n_bin:\n        number of PercentileDiscretizer bins used for PercentileDiscretizer calibration.\n        Used to initialize bin_values, hash_keys, hash_values,\n        bin_ids, bin_values and feature_offsets.\n      out_bits:\n        Determines the maximum value for output feature IDs.\n        The dense_shape of the SparseTensor returned by lookup(x)\n        will be [x.shape[0], 1 << output_bits].\n\n    Optional args:\n      hash_keys:\n        contains the features ID that PercentileDiscretizer discretizes and knows about.\n        The hash map (hash_keys->hash_values) is used for two reasons:\n          1. divide inputs into two feature spaces:\n          PercentileDiscretizer vs non-PercentileDiscretizer\n          2. transate the PercentileDiscretizer features into a hash_feature ID that\n          PercentileDiscretizer understands.\n        The hash_map is expected to contain n_feature items.\n      hash_values:\n        translates the feature IDs into hash_feature IDs for PercentileDiscretizer.\n      bin_ids:\n        a 1D Tensor of size n_feature * n_bin + 1 which contains\n        unique IDs to which the PercentileDiscretizer features will be translated to.\n        For example, tf.Tensor(np.arange(n_feature * n_bin)) would produce\n        the most efficient output space.\n      bin_values:\n        a 1D Tensor aligned with bin_ids.\n        For a given hash_feature ID j, it\'s value bin\'s are indexed between\n        `j*n_bin` and `j*n_bin + n_bin-1`.\n        As such, bin_ids[j*n_bin+i] is translated from a hash_feature ID of j\n        and a inputs value between\n        `bin_values[j*n_bin + i]` and `bin_values[j*n_bin+i+1]`.\n      feature_offsets:\n        a 1D Tensor specifying the starting location of bins for a given feature id.\n        For example, tf.Tensor(np.arange(0, bin_values.size, n_bin, dtype=\'int64\')).\n    ';C=feature_offsets;D=bin_ids;E=hash_values;F=hash_keys;G=bin_values;H=out_bits;I=n_bin;B=n_feature;super(PercentileDiscretizer,A).__init__(**K)
		if not A.built:A.build(input_shape=_A)
		J=B*(I+1);A._n_feature=B;A._n_bin=I;A._out_bits=H;A._output_size=tf.convert_to_tensor(1<<H,tf.int64);A._hash_keys=F if F is not _A else np.empty(B,dtype=np.int64);A._hash_values=E if E is not _A else np.empty(B,dtype=np.int64);A._bin_ids=D if D is not _A else np.empty(J,dtype=np.int64);A._bin_values=G if G is not _A else np.empty(J,dtype=np.float32);A._feature_offsets=C if C is not _A else np.empty(B,dtype=np.int64);A.num_parts=num_parts;A.cost_per_unit=cost_per_unit
	def build(A,input_shape):'\n    Creates the variables of the layer\n    ';A.built=True
	def call(A,inputs,keep_inputs=False,**Q):
		'Looks up `keys` in a table, outputs the corresponding values.\n\n    Implements PercentileDiscretizer inference where inputs are intersected with a hash_map.\n    Input features that were not calibrated have their feature IDs truncated, so as\n    to be less than 1<<output_bits, but their values remain untouched (not discretized)\n\n    If there are no calibrated features, then the discretizer will only apply\n    twml.util.limit_bits to the the feature keys (aka "feature_ids"). Essentially,\n    the discretizer will be a "no-operation", other than obeying `out_bits`\n\n    Args:\n      inputs: A 2D SparseTensor that is input to PercentileDiscretizer for discretization.\n        It has a dense_shape of [batch_size, input_size]\n      keep_inputs:\n        Include the original inputs in the output.\n        Note - if True, undiscretized features will be passed through, but will have\n        their values doubled (unless there are no calibrated features to discretize).\n      name: A name for the operation (optional).\n    Returns:\n      A `SparseTensor` of the same type as `inputs`.\n      Its dense_shape is [shape_input.dense_shape[0], 1 << output_bits].\n    ';G=keep_inputs;B=inputs
		if isinstance(B,tf.SparseTensor):B=twml.SparseTensor.from_tf(B)
		assert isinstance(B,twml.SparseTensor);H=B.ids;C=B.indices;D=B.values
		if A._n_feature>0:I,J=libtwml.ops.percentile_discretizer_v2(input_ids=C,input_vals=D,bin_ids=A._bin_ids,bin_vals=A._bin_values,feature_offsets=A._feature_offsets,output_bits=A._out_bits,feature_ids=tf.make_tensor_proto(A._hash_keys),feature_indices=tf.make_tensor_proto(A._hash_values),start_compute=tf.constant(0,shape=[],dtype=tf.int64),end_compute=tf.constant(-1,shape=[],dtype=tf.int64),cost_per_unit=A.cost_per_unit)
		else:I=twml.util.limit_bits(C,A._out_bits);J=D;G=False
		M=tf.to_int64(B.dense_shape[0]);E=[M,A._output_size];F=twml.SparseTensor(H,I,J,E).to_tf()
		if G:K=A._n_feature*(A._n_bin+1);N=tf.subtract(A._output_size,K);O=tf.add(tf.floormod(C,N),K);P=twml.SparseTensor(ids=H,indices=O,values=D,dense_shape=E).to_tf();L=tf.sparse_add(P,F);F=tf.SparseTensor(L.indices,L.values,E)
		return F
	def compute_output_shape(A,input_shape):'Computes the output shape of the layer given the input shape.\n\n    Args:\n      input_shape: A (possibly nested tuple of) `TensorShape`.  It need not\n        be fully defined (e.g. the batch size may be unknown).\n\n    Raises NotImplementedError.\n\n    ';raise NotImplementedError