import tensorflow.compat.v1 as tf
from tensorflow.python.ops import array_ops,math_ops
def safe_div(numerator,denominator,name=None):'\n  Example usage: calculating NDCG = DCG / IDCG to handle cases when\n  IDCG = 0 returns 0 instead of Infinity \n  Do not use this dividing funciton unless it makes sense to your problem\n  Divides two tensors element-wise, returns 0 if the denominator is <= 0.\n  Args:\n    numerator: a real `Tensor`.\n    denominator: a real `Tensor`, with dtype matching `numerator`.\n    name: Name for the returned op.\n  Returns:\n    0 if `denominator` <= 0, else `numerator` / `denominator`\n  ';B=denominator;C=math_ops.truediv(numerator,B);A=array_ops.zeros_like(C,dtype=B.dtype);D=math_ops.greater(B,A);A=math_ops.cast(A,C.dtype);return array_ops.where(D,C,A,name=name)
def cal_ndcg(label_scores,predicted_scores,top_k_int=1):'\n  Calculate NDCG score for top_k_int ranking positions\n  Args:\n    label_scores: a real `Tensor`.\n    predicted_scores: a real `Tensor`, with dtype matching label_scores\n    top_k_int: An int or an int `Tensor`.\n  Returns:\n    a `Tensor` that holds DCG / IDCG.\n  ';A=top_k_int;C,D=_get_ranking_orders(label_scores,predicted_scores,top_k_int=A);E=_get_relevance_scores(D);F=_get_relevance_scores(C);B=_get_cg_discount(A);G=_dcg_idcg(E,B);H=_dcg_idcg(F,B);I=safe_div(G,H,'one_ndcg');return I
def cal_swapped_ndcg(label_scores,predicted_scores,top_k_int):'\n  Calculate swapped NDCG score in Lambda Rank for full/top k ranking positions\n  Args:\n    label_scores: a real `Tensor`.\n    predicted_scores: a real `Tensor`, with dtype matching label_scores\n    top_k_int: An int or an int `Tensor`. \n  Returns:\n    a `Tensor` that holds swapped NDCG by .\n  ';A=top_k_int;G,H=_get_ranking_orders(label_scores,predicted_scores,top_k_int=A);C=_get_relevance_scores(H);I=_get_relevance_scores(G);B=_get_cg_discount(A);D=C/B;E=tf.reduce_sum(D);J=I/B;F=tf.reduce_sum(J);K=safe_div(E,F,'ndcg_in_lambdarank_training');L=tf.tile(D,[1,A]);M=C/tf.transpose(B);N=tf.tile(tf.transpose(D),[A,1]);O=tf.transpose(C)/B;P=E-L+M-N+O;Q=safe_div(P,F,'new_ndcg_in_lambdarank_training');R=tf.abs(K-Q);return R
def _dcg_idcg(relevance_scores,cg_discount):'\n  Calculate DCG scores for top_k_int ranking positions\n  Args:\n    relevance_scores: a real `Tensor`.\n    cg_discount: a real `Tensor`, with dtype matching relevance_scores\n  Returns:\n    a `Tensor` that holds \\sum_{i=1}^k \x0crac{relevance_scores_k}{cg_discount}  \n  ';A=relevance_scores/cg_discount;return tf.reduce_sum(A)
def _get_ranking_orders(label_scores,predicted_scores,top_k_int=1):'\n  Calculate DCG scores for top_k_int ranking positions\n  Args:\n    label_scores: a real `Tensor`.\n    predicted_scores: a real `Tensor`, with dtype matching label_scores\n    top_k_int: an integer or an int `Tensor`.\n  Returns:\n    two `Tensors` that hold sorted_labels: the ground truth relevance socres\n    and predicted_order: relevance socres based on sorted predicted_scores\n  ';D=top_k_int;B=predicted_scores;A=label_scores;A=tf.reshape(A,[-1,1]);B=tf.reshape(B,[-1,1]);C,H=tf.nn.top_k(tf.transpose(A),k=D);C=tf.transpose(C);I,E=tf.nn.top_k(tf.transpose(B),k=D);F=tf.transpose(E);G=tf.gather_nd(A,F);return C,G
def _get_cg_discount(top_k_int=1):'\n  Calculate discounted gain factor for ranking position till top_k_int\n  Args:\n    top_k_int: An int or an int `Tensor`.\n  Returns:\n    a `Tensor` that holds \\log_{2}(i + 1), i \\in [1, k] \n  ';B=tf.log(tf.constant(2.0,dtype=tf.float32));A=tf.range(top_k_int)+1;A=tf.reshape(A,[-1,1]);A=tf.cast(A,dtype=tf.float32);C=tf.log(A+1.0)/B;return C
def _get_relevance_scores(scores):return 2**scores-1
def safe_log(raw_scores,name=None):'\n  Calculate log of a tensor, handling cases that\n  raw_scores are close to 0s\n  Args:\n    raw_scores: An float `Tensor`.\n  Returns:\n    A float `Tensor` that hols the safe log base e of input\n  ';A=1e-08;B=tf.maximum(raw_scores,A);return tf.log(B)