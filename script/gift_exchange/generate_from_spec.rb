# frozen_string_literal: true

require 'json'

unless ARGV.size == 2
  puts "
    Usage: ruby generate_from_spec.rb <JSON_SPEC> <JSON_OUTPUT>

    Given a JSON file specifying information about an exchange (possibly
    generated by export_settings_json.rb, or possibly hand-crafted),
    randomly generate a collection of challenge signups fitting the specs
    and output to the <JSON_OUTPUT> file.

    Does not use Rails, only Ruby.
  "
  exit
end

# TAG_SAMPLE_TYPE = 'uniform'.freeze
TAG_SAMPLE_TYPE = 'geometric'
# TAG_SAMPLE_TYPE = 'harmonic'.freeze

######################################################################
# Functions handling the loading and accessing of tags.
# Also some assorted utility functions.
######################################################################

PLURAL_TAG_TYPES = %w(
  fandoms
  characters
  relationships
  freeforms
  ratings
  archive_warnings
  categories
).freeze

# Checks whether this type is one of the nested ones.
def nested?(type)
  %w(characters relationships).include? type
end

# Makes the type singular.
def singular(type)
  type.gsub(/ies$/, 'y').gsub(/s$/, '')
end

# Builds a taglist based on the given seed.  Samples if the seed is too large,
# adds boring numbered tags if the seed is too small.
def make_tag_list(type, seed, limit)
  seed = [] if seed.nil?
  limit = seed.size if limit.nil?

  prefix = singular(type) + ' '

  result = seed.sample(limit)
  result << (prefix + result.size.to_s) while result.size < limit

  result
end

# Loads the "tag seed" and uses the passed-in limits to generate the tag set of
# the exchange.
def load_tags(limits)
  @limits = limits.dup

  script_path = File.expand_path(__FILE__)
  script_directory = File.dirname(script_path)
  tag_seed_path = File.join(script_directory, 'tag_seed.json')

  tag_seed = JSON.load(File.open(tag_seed_path, 'r'))

  @all_tags = {}
  PLURAL_TAG_TYPES.each do |type|
    next if type == 'fandoms' # this is handled separately
    next if nested?(type)
    @all_tags[type] = make_tag_list(type, tag_seed[type], @limits[type])
  end

  load_fandoms(tag_seed['fandoms'] || {})
end

# Stores information about fandoms.
def load_fandoms(fandom_info)
  @all_tags['fandoms'] = make_tag_list(
    'fandoms', fandom_info.keys, @limits['fandoms']
  )

  @nested_tags = {}

  @all_tags['fandoms'].each do |fandom|
    characters = make_tag_list(
      'characters', fandom_info[fandom], @limits['characters']
    )

    all_ships = characters.combination(2).to_a.map do |list|
      list.join('/')
    end

    ships = make_tag_list(
      'relationships', all_ships, @limits['relationships']
    )

    @nested_tags[fandom] = {
      'characters' => characters.map { |c| "#{c} (#{fandom})" },
      'relationships' => ships.map { |r| "#{r} (#{fandom})" }
    }
  end
end

def sample_from_list(list, count)
  if count > list.size
    raise "Can't sample #{count} items from #{list}, because there aren't that many unique items!"
  end

  case TAG_SAMPLE_TYPE
  when 'harmonic'
    return sample_from_list_harmonic(list, count)
  when 'geometric'
    return sample_from_list_geometric(list, count)
  else
    return sample_from_list_uniform(list, count)
  end
end

# Sample items with harmonic probabilities.
# (That is, where the weight is proportional to 1 / index.)
def sample_from_list_harmonic(list, count)
  weights = (1..list.size).map { |index| 1.0 / index }

  sample = []

  while sample.size < count
    value = weights.inject(0, :+) * rand

    index = weights.find_index do |weight|
      value -= weight
      value < 0
    end

    sample << list[index]
    weights[index] = 0
  end

  sample
end

# Sample geometrically from the given list.
# It's as if there's an inherent "ranking" to all of the tags, so that people
# are more enthusiastic about Fandom 1 than Fandom 2, and more enthusiastic
# about Fandom 2 than Fandom 3, and so on. But not everyone likes Fandom 1 --
# many haven't tried it, or just aren't really in agreement with the consensus.
# So there's a certain chance that they'll pass on Fandom 1 and see if they
# like the next fandom better.
def sample_from_list_geometric(list, count)
  probability = 2.0 * count.to_f / list.size

  loop do
    sample = []

    list.each do |item|
      sample << item if rand < probability
      return sample if sample.size == count
    end
  end
end

# Samples uniformly from the given list.
# Uses Ruby's built-in sample function.
def sample_from_list_uniform(list, count)
  list.sample(count)
end

# Samples the specified number of tags.
def sample_tags(type, fandom_list, count)
  if nested?(type)
    if fandom_list.nil? || fandom_list.empty?
      # It's a single-fandom exchange, so just take the first fandom.
      fandom_list = [@all_tags['fandoms'].first]
    end

    sample_domain = fandom_list.flat_map do |fandom|
      @nested_tags[fandom][type]
    end

    sample_from_list(sample_domain, count)
  else
    sample_from_list(@all_tags[type], count)
  end
end

# Generates a random count, according to the given spec.
def generate_count(spec)
  # we use independent random trials for this
  # so that we ought to get a nice bell-ish curve around the average

  min = spec['min']
  max = spec['max']
  average = spec['average']

  if max < min || average < min || average > max
    raise "Invalid count specification: #{spec}."
  end

  probability = (average - min).to_f / (max - min)

  count = min
  (max - min).times do
    count += 1 if rand < probability
  end

  count
end

######################################################################
# Functions for generating random prompts.
######################################################################

# Class used to store information about a tag generation task.
# (Because unique and non-unique tags behave differently.)
TagTask = Struct.new(:list, :fandoms, :count)

# Generate tags of the given type for the specified list of tag generation
# tasks.
def generate_tags(type, tasks)
  tasks.each do |task|
    sampled = sample_tags(type, task.fandoms, task.count)
    sampled.each { |tag| task.list << tag }
  end
end

# Generates UNIQUE tags of the given type for the specified list of tag
# generation tasks. Ignores the fandoms specified by the given list of tasks,
# and uses the override_fandoms list instead.
def generate_unique_tags(type, tasks, override_fandoms = nil)
  total = tasks.inject(0) { |sum, task| sum + task.count }

  all = sample_tags(type, override_fandoms, total).shuffle

  tasks.each do |task|
    sampled = all.shift(task.count)
    sampled.each { |tag| task.list << tag }
  end
end

# Generates unique tags for the passed-in nested tag type.
def generate_unique_nested_tags(type, tasks)
  by_fandom = {}

  tasks.each do |task|
    if task.fandoms.nil? || task.fandoms.empty?
      by_fandom[nil] ||= []
      by_fandom[nil] << task
    elsif task.fandoms.size == 1
      by_fandom[task.fandoms.first] ||= []
      by_fandom[task.fandoms.first] << task
    else
      raise "Can't sample unique #{type} in an exchange that allows multiple fandoms per prompt!"
    end
  end

  by_fandom.each_pair do |fandom, fandom_tasks|
    generate_unique_tags(type, fandom_tasks, [fandom].compact)
  end
end

# For each of the passed-in prompts, generate tags of the specified type.
def generate_type(type, spec, prompts)
  tasks = []

  prompts.each do |prompt|
    if spec.key?('any') && rand < spec['any']
      prompt['any'] ||= []
      prompt['any'] << singular(type)
    else
      count = generate_count(spec)
      prompt[type] = []
      tasks << TagTask.new(prompt[type], prompt['fandoms'], count)
    end
  end

  if spec.key?('unique') && spec['unique']
    if nested?(type)
      generate_unique_nested_tags(type, tasks)
    else
      generate_unique_tags(type, tasks)
    end
  else
    generate_tags(type, tasks)
  end
end

# Generates prompts according to the spec.
def generate_prompts(spec)
  count = generate_count(spec['prompts'])

  prompts = []
  count.times do
    prompts << {}
  end

  PLURAL_TAG_TYPES.each do |type|
    next unless spec.key? type
    generate_type(type, spec[type], prompts)
  end

  prompts
end

######################################################################
# Actually generating all of the signups!
######################################################################

# Generates random signups according to the spec.
def generate_signup(username, spec)
  signup = { 'pseud' => username }

  %w(offers requests).each do |prompt_type|
    signup[prompt_type] = generate_prompts(spec[prompt_type])
  end

  signup
end

# Actually do all the work!
spec_file = ARGV[0]
signups_file = ARGV[1]

spec = JSON.load(File.open(spec_file, 'r'))

load_tags(spec['tag_limits'])

signups = []

spec['participants'].times do |index|
  username = "testuser#{index + 1}"
  signups << generate_signup(username, spec)
end

JSON.dump(signups, File.open(signups_file, 'w'))
