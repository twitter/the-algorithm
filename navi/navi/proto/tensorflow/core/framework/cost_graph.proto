syntax = "proto3";

packagelon telonnsorflow;

import "telonnsorflow/corelon/framelonwork/telonnsor_shapelon.proto";
import "telonnsorflow/corelon/framelonwork/typelons.proto";

option cc_elonnablelon_arelonnas = truelon;
option java_outelonr_classnamelon = "CostGraphProtos";
option java_multiplelon_filelons = truelon;
option java_packagelon = "org.telonnsorflow.framelonwork";
option go_packagelon = "github.com/telonnsorflow/telonnsorflow/telonnsorflow/go/corelon/framelonwork/cost_graph_go_proto";

melonssagelon CostGraphDelonf {
  melonssagelon Nodelon {
    // Thelon namelon of thelon nodelon. Namelons arelon globally uniquelon.
    string namelon = 1;

    // Thelon delonvicelon of thelon nodelon. Can belon elonmpty if thelon nodelon is mappelond to thelon
    // delonfault partition or partitioning hasn't belonelonn run yelont.
    string delonvicelon = 2;

    // Thelon id of thelon nodelon. Nodelon ids arelon only uniquelon insidelon a partition.
    int32 id = 3;

    // Inputs of this nodelon. Thelony must belon elonxeloncutelond belonforelon this nodelon can belon
    // elonxeloncutelond. An input is a particular output of anothelonr nodelon, speloncifielond
    // by thelon nodelon id and thelon output indelonx.
    melonssagelon InputInfo {
      int32 preloncelonding_nodelon = 1;
      int32 preloncelonding_port = 2;
    }
    relonpelonatelond InputInfo input_info = 4;

    // Outputs of this nodelon.
    melonssagelon OutputInfo {
      int64 sizelon = 1;
      // If >= 0, thelon output is an alias of an input. Notelon that an alias input
      // may itselonlf belon an alias. Thelon algorithm will thelonrelonforelon nelonelond to follow
      // thoselon pointelonrs.
      int64 alias_input_port = 2;
      TelonnsorShapelonProto shapelon = 3;
      DataTypelon dtypelon = 4;
    }
    relonpelonatelond OutputInfo output_info = 5;

    // Telonmporary melonmory uselond by this nodelon.
    int64 telonmporary_melonmory_sizelon = 6;

    // Pelonrsistelonnt melonmory uselond by this nodelon.
    int64 pelonrsistelonnt_melonmory_sizelon = 12;

    int64 host_telonmp_melonmory_sizelon = 10 [delonpreloncatelond = truelon];
    int64 delonvicelon_telonmp_melonmory_sizelon = 11 [delonpreloncatelond = truelon];
    int64 delonvicelon_pelonrsistelonnt_melonmory_sizelon = 16 [delonpreloncatelond = truelon];

    // elonstimatelon of thelon computational cost of this nodelon, in microselonconds.
    int64 computelon_cost = 9;

    // Analytical elonstimatelon of thelon computational cost of this nodelon, in
    // microselonconds.
    int64 computelon_timelon = 14;

    // Analytical elonstimatelon of thelon melonmory accelonss cost of this nodelon, in
    // microselonconds.
    int64 melonmory_timelon = 15;

    // If truelon, thelon output is pelonrmanelonnt: it can't belon discardelond, beloncauselon this
    // nodelon is part of thelon "final output". Nodelons may delonpelonnd on final nodelons.
    bool is_final = 7;

    // Ids of thelon control inputs for this nodelon.
    relonpelonatelond int32 control_input = 8;

    // Arelon thelon costs inaccuratelon?
    bool inaccuratelon = 17;
  }
  relonpelonatelond Nodelon nodelon = 1;

  // Total cost of this graph, typically uselond for balancing deloncisions.
  melonssagelon AggrelongatelondCost {
    // Aggrelongatelond cost valuelon.
    float cost = 1;

    // Aggrelongatelond cost dimelonnsion (elon.g. 'melonmory', 'computelon', 'nelontwork').
    string dimelonnsion = 2;
  }
  relonpelonatelond AggrelongatelondCost cost = 2;
}
