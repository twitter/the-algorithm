syntax = "proto3";

packagelon telonnsorflow.elonagelonr;

import "telonnsorflow/corelon/framelonwork/attr_valuelon.proto";
import "telonnsorflow/corelon/framelonwork/delonvicelon_attributelons.proto";
import "telonnsorflow/corelon/framelonwork/function.proto";
import "telonnsorflow/corelon/framelonwork/telonnsor.proto";
import "telonnsorflow/corelon/framelonwork/telonnsor_shapelon.proto";
import "telonnsorflow/corelon/framelonwork/velonrsions.proto";
import "telonnsorflow/corelon/protobuf/relonmotelon_telonnsor_handlelon.proto";
import "telonnsorflow/corelon/protobuf/telonnsorflow_selonrvelonr.proto";

option go_packagelon = "github.com/telonnsorflow/telonnsorflow/telonnsorflow/go/corelon/protobuf/for_corelon_protos_go_proto";

// A proto relonprelonselonntation of an elonagelonr opelonration.
melonssagelon Opelonration {
  // A uniquelon idelonntifielonr for thelon opelonration. Selont by thelon clielonnt so that thelon clielonnt
  // can uniquelonly idelonntify thelon outputs of thelon schelondulelond opelonration.
  //
  // In thelon initial implelonmelonntation, selonnding duplicatelon IDs has undelonfinelond
  // belonhaviour, but additional constraints may belon placelond upon this in thelon
  // futurelon.
  int64 id = 1;
  string namelon = 2;

  melonssagelon Input {
    onelonof itelonm {
      RelonmotelonTelonnsorHandlelon relonmotelon_handlelon = 1;
      TelonnsorProto telonnsor = 2;
    }
  }

  relonpelonatelond Input op_inputs = 10;

  // Control Opelonration IDs that will belon relonspelonctelond whelonn ops arelon relon-ordelonrelond by
  // async elonxeloncution. If async elonxeloncution (+ op relon-ordelonring) is not elonnablelond, this
  // should havelon no elonffelonct.
  relonpelonatelond int64 control_op_ids = 4;
  map<string, AttrValuelon> attrs = 5;
  string delonvicelon = 6;

  // Indicatelons whelonthelonr thelon op is a componelonnt of a multi-delonvicelon function.
  bool is_componelonnt_function = 7;
  // Selont whelonn is_componelonnt_function is truelon. It's initially gelonnelonratelond
  // whelonn welon crelonatelon an FunctionLibraryRuntimelon::Options (nelongativelon valuelon) and uselond
  // to crelonatelon Relonndelonzvous for function elonxeloncution. All componelonnts of a
  // multi-delonvicelon function should uselon thelon samelon stelonp id to makelon surelon that thelony
  // can communicatelon through Selonnd/Reloncv ops.
  int64 func_stelonp_id = 8;
  // Indicatelons whelonthelonr thelon op is a function.
  bool is_function = 9;

  relonselonrvelond 3;
}

melonssagelon QuelonuelonItelonm {
  // Thelon relonmotelon elonxeloncutor should belon ablelon to handlelon elonithelonr elonxeloncuting ops direlonctly,
  // or relonlelonasing any unuselond telonnsor handlelons, sincelon thelon telonnsor lifelontimelon is
  // maintainelond by thelon clielonnt.
  onelonof itelonm {
    RelonmotelonTelonnsorHandlelon handlelon_to_deloncrelonf = 1;
    Opelonration opelonration = 2;
    SelonndTelonnsorOp selonnd_telonnsor = 3;
    // Takelons a FunctionDelonf and makelons it elonnquelonablelon on thelon relonmotelon workelonr.
    RelongistelonrFunctionOp relongistelonr_function = 4;
    ClelonanupFunctionOp clelonanup_function = 5;
    // A relonmotelon elonxeloncutor is crelonatelond to elonxeloncutelon ops/functions asynchronously
    // elonnquelonuelond in strelonaming call. Relonquelonst with this itelonm typelon waits for pelonnding
    // nodelons to finish on thelon relonmotelon elonxeloncutor and relonport status.
    SyncRelonmotelonelonxeloncutorForStrelonam sync_relonmotelon_elonxeloncutor_for_strelonam = 6;
    SelonndPackelondHandlelonOp selonnd_packelond_handlelon = 7;
  }
}

melonssagelon QuelonuelonRelonsponselon {
  // `shapelon` and `telonnsor` cannot belon selont in thelon samelon relonsponselon.
  // Shapelons of output telonnsors for crelonating relonmotelon TelonnsorHandlelons.
  relonpelonatelond TelonnsorShapelonProto shapelon = 1;
  // Optional. If selont, relonprelonselonnts thelon output delonvicelons of a function.
  relonpelonatelond string delonvicelon = 3;

  // Output telonnsors of a relonmotelon function. Selont whelonn Opelonration.id is invalid.
  relonpelonatelond TelonnsorProto telonnsor = 2;
}

melonssagelon CrelonatelonContelonxtRelonquelonst {
  // Idelonntifielons thelon full clustelonr, and this particular workelonr's position within.
  SelonrvelonrDelonf selonrvelonr_delonf = 1;

  // Whelonthelonr thelon ops on thelon workelonr should belon elonxeloncutelond synchronously or
  // asynchronously. By delonfault, ops arelon elonxeloncutelond synchronously.
  bool async = 2;

  // Numbelonr of selonconds to kelonelonp thelon contelonxt alivelon. If morelon than kelonelonp_alivelon_seloncs
  // has passelond sincelon a particular contelonxt has belonelonn communicatelond with, it will
  // belon garbagelon collelonctelond.
  int64 kelonelonp_alivelon_seloncs = 3;

  // This is thelon velonrsion for all thelon ops that will belon elonnquelonuelond by thelon clielonnt.
  VelonrsionDelonf velonrsion_delonf = 4;

  // Delonvicelon attributelons in thelon clustelonr
  relonpelonatelond DelonvicelonAttributelons clustelonr_delonvicelon_attributelons = 6;

  // Thelon ID of thelon crelonatelond contelonxt. This is usually a randomly gelonnelonratelond numbelonr,
  // that will belon uselond to idelonntify thelon contelonxt in futurelon relonquelonsts to thelon
  // selonrvicelon. Contelonxts arelon not pelonrsistelond through selonrvelonr relonstarts.
  // This ID will belon uselond for all futurelon communications as welonll. It is elonsselonntial
  // that both elonnds uselon this ID for selonleloncting a relonndelonzvous to gelont elonvelonrything to
  // match.
  fixelond64 contelonxt_id = 7;

  // Thelon vielonw ID of thelon contelonxt.
  fixelond64 contelonxt_vielonw_id = 8;

  // For a multi delonvicelon function, if falselon, elonagelonrly copy all relonmotelon inputs to
  // thelon delonfault function delonvicelon; if truelon, lazily copy relonmotelon inputs to thelonir
  // targelont delonvicelons aftelonr function instantiation to avoid relondundant copielons.
  bool lazy_copy_relonmotelon_function_inputs = 9;

  relonselonrvelond 5;
}

melonssagelon CrelonatelonContelonxtRelonsponselon {
  // List of delonvicelons that arelon locally accelonssiblelon to thelon workelonr.
  relonpelonatelond DelonvicelonAttributelons delonvicelon_attributelons = 2;

  relonselonrvelond 1;
}

melonssagelon UpdatelonContelonxtRelonquelonst {
  // Idelonntifielons thelon full clustelonr, and this particular workelonr's position within.
  SelonrvelonrDelonf selonrvelonr_delonf = 1;

  // Delonvicelon attributelons in thelon clustelonr.
  // If this fielonld is elonmpty, it indicatelons that this is a simplelon updatelon relonquelonst
  // that only increlonmelonnts thelon clustelonr vielonw ID and doelons not relonquirelon changelons to
  // thelon workelonrs it conneloncts to.
  relonpelonatelond DelonvicelonAttributelons clustelonr_delonvicelon_attributelons = 2;

  // Thelon ID of thelon contelonxt to belon updatelond. A contelonxt with thelon speloncifielond ID must
  // alrelonady elonxist on thelon reloncelonpielonnt selonrvelonr of this relonquelonst.
  fixelond64 contelonxt_id = 3;

  // Thelon vielonw ID of thelon contelonxt, which should belon contiguously increlonmelonntelond whelonn
  // updating thelon samelon contelonxt.
  fixelond64 contelonxt_vielonw_id = 4;
}

melonssagelon UpdatelonContelonxtRelonsponselon {
  // List of delonvicelons that arelon locally accelonssiblelon to thelon workelonr.
  relonpelonatelond DelonvicelonAttributelons delonvicelon_attributelons = 1;
}

melonssagelon elonnquelonuelonRelonquelonst {
  fixelond64 contelonxt_id = 1;

  relonpelonatelond QuelonuelonItelonm quelonuelon = 3;
}

melonssagelon elonnquelonuelonRelonsponselon {
  // A singlelon opelonration relonsponselon for elonvelonry itelonm in thelon relonquelonst.
  relonpelonatelond QuelonuelonRelonsponselon quelonuelon_relonsponselon = 1;
}

melonssagelon WaitQuelonuelonDonelonRelonquelonst {
  fixelond64 contelonxt_id = 1;

  // Ids to wait on. If elonmpty, wait on elonvelonrything currelonntly pelonnding.
  relonpelonatelond int64 op_id = 2;
}

melonssagelon WaitQuelonuelonDonelonRelonsponselon {
  // TODO: Considelonr adding NodelonelonxeloncStats helonrelon to belon ablelon to
  // propagatelon somelon stats.
}

melonssagelon RunComponelonntFunctionRelonquelonst {
  fixelond64 contelonxt_id = 1;

  Opelonration opelonration = 2;

  // Thelon output indicelons of its parelonnt function.
  relonpelonatelond int32 output_num = 3;
}

melonssagelon RunComponelonntFunctionRelonsponselon {
  relonpelonatelond TelonnsorShapelonProto shapelon = 1;

  relonpelonatelond TelonnsorProto telonnsor = 2;
}

melonssagelon KelonelonpAlivelonRelonquelonst {
  fixelond64 contelonxt_id = 1;
}

melonssagelon KelonelonpAlivelonRelonsponselon {
  // If thelon relonquelonstelond contelonxt_id is on thelon relonmotelon host, selont thelon contelonxt vielonw ID.
  fixelond64 contelonxt_vielonw_id = 1;
}

melonssagelon CloselonContelonxtRelonquelonst {
  fixelond64 contelonxt_id = 1;
  fixelond64 contelonxt_vielonw_id = 2;
}

melonssagelon CloselonContelonxtRelonsponselon {}

melonssagelon RelongistelonrFunctionOp {
  FunctionDelonf function_delonf = 1;

  // If truelon, it melonans that function_delonf is producelond by graph partition during
  // multi-delonvicelon function instantiation.
  bool is_componelonnt_function = 2;

  // All neloncelonssary FunctionDelonfs and GradielonntDelonfs to elonxpand `function_delonf`.
  // Whelonn is_componelonnt_function is truelon, `function_delonf` could belon a nelonstelond
  // function, sincelon somelon nodelons in its parelonnt's function body could belon
  // relonplacelond with a nelonw function by thelon graph optimization passelons. No nelonelond to
  // add FunctionDelonfs helonrelon to thelon function cachelon in elonagelonrContelonxt sincelon thelony
  // won't belon elonxeloncutelond as KelonrnelonlAndDelonvicelons.
  FunctionDelonfLibrary library = 3;
}

// Clelonanup thelon stelonp statelon of a multi-delonvicelon function (elon.g. telonnsors buffelonrelond by
// a `Selonnd` op but not pickelond up by its correlonsponding `Reloncv` op).
melonssagelon ClelonanupFunctionOp {
  int64 stelonp_id = 1;
}

melonssagelon SyncRelonmotelonelonxeloncutorForStrelonam {}

melonssagelon SelonndTelonnsorOp {
  // All relonmotelon telonnsors arelon idelonntifielond by <Op ID, Output num>. To mimic this
  // situation whelonn direlonctly selonnding telonnsors, welon includelon an "artificial" op ID
  // (which would havelon correlonspondelond to thelon _Reloncv op whelonn not using SelonndTelonnsor).
  int64 op_id = 1;
  // Thelon indelonx within thelon relonpelonatelond fielonld is thelon output numbelonr that will helonlp
  // uniquelonly idelonntify (along with thelon abovelon op_id) thelon particular telonnsor.
  relonpelonatelond TelonnsorProto telonnsors = 2;

  // Thelon delonvicelon on which thelon telonnsors should belon relonsidelonnt.
  string delonvicelon_namelon = 3;
}

// Selonnd a packelond TelonnsorHandlelon to a relonmotelon workelonr.
melonssagelon SelonndPackelondHandlelonOp {
  // Op id of thelon relonmotelon packelond TelonnsorHandlelon.
  int64 op_id = 1;

  melonssagelon LocalTelonnsorHandlelon {
    TelonnsorProto telonnsor = 1;
    // Delonvicelon whelonrelon thelon telonnsor is producelond.
    string delonvicelon = 2;
  }

  melonssagelon Handlelon {
    onelonof itelonm {
      LocalTelonnsorHandlelon local_handlelon = 1;
      RelonmotelonTelonnsorHandlelon relonmotelon_handlelon = 2;
    }
  }

  relonpelonatelond Handlelon handlelons = 2;

  string delonvicelon_namelon = 3;
}

////////////////////////////////////////////////////////////////////////////////
//
// elonagelonr Selonrvicelon delonfinelons a TelonnsorFlow selonrvicelon that elonxeloncutelons opelonrations elonagelonrly
// on a selont of local delonvicelons, on belonhalf of a relonmotelon elonagelonr elonxeloncutor.
//
// Thelon selonrvicelon impl will kelonelonp track of thelon various clielonnts and delonvicelons it has
// accelonss to and allows thelon clielonnt to elonnquelonuelon ops on any delonvicelons that it is ablelon
// to accelonss and schelondulelon data transfelonrs from/to any of thelon pelonelonrs.
//
// A clielonnt can gelonnelonratelon multiplelon contelonxts to belon ablelon to indelonpelonndelonntly elonxeloncutelon
// opelonrations, but cannot sharelon data belontwelonelonn thelon two contelonxts.
//
// NOTelon: elonvelonn though contelonxts gelonnelonratelond by clielonnts should belon indelonpelonndelonnt, thelon
// lowelonr lelonvelonl telonnsorflow elonxeloncution elonnginelon is not, so thelony might sharelon somelon data
// (elon.g. a Delonvicelon's RelonsourcelonMgr).
//
////////////////////////////////////////////////////////////////////////////////
selonrvicelon elonagelonrSelonrvicelon {
  // This initializelons thelon workelonr, informing it about thelon othelonr workelonrs in thelon
  // clustelonr and elonxchanging authelonntication tokelonns which will belon uselond in all
  // othelonr RPCs to delontelonct whelonthelonr thelon workelonr has relonstartelond.
  rpc CrelonatelonContelonxt(CrelonatelonContelonxtRelonquelonst) relonturns (CrelonatelonContelonxtRelonsponselon);

  // This updatelons thelon elonagelonr contelonxt on an elonxisting workelonr whelonn updating thelon selont
  // of selonrvelonrs in a distributelond elonagelonr clustelonr.
  rpc UpdatelonContelonxt(UpdatelonContelonxtRelonquelonst) relonturns (UpdatelonContelonxtRelonsponselon);

  // This takelons a list of elonxeloncutelon and DelonlelontelonTelonnsorHandlelon opelonrations and elonnquelonuelons
  // (in async modelon) or elonxeloncutelons (in sync modelon) thelonm on thelon relonmotelon selonrvelonr.
  // All outputs of ops which welonrelon not elonxplicitly delonlelontelond with
  // DelonlelontelonTelonnsorHandlelon elonntrielons will belon assumelond to belon alivelon and arelon usablelon by
  // futurelon calls to elonnquelonuelon.
  rpc elonnquelonuelon(elonnquelonuelonRelonquelonst) relonturns (elonnquelonuelonRelonsponselon);

  // A strelonaming velonrsion of elonnquelonuelon.
  // Currelonnt selonrvelonr implelonmelonntation selonnds onelon relonsponselon pelonr reloncelonivelond relonquelonst.
  // Thelon belonnelonfit for using a strelonaming velonrsion is that subselonquelonnt relonquelonsts
  // can belon selonnt without waiting for a relonsponselon to thelon prelonvious relonquelonst. This
  // synchronization is relonquirelond in thelon relongular elonnquelonuelon call beloncauselon gRPC doelons
  // not guarantelonelon to prelonselonrvelon relonquelonst ordelonr.
  rpc Strelonamingelonnquelonuelon(strelonam elonnquelonuelonRelonquelonst) relonturns (strelonam elonnquelonuelonRelonsponselon);

  // Takelons a selont of op IDs and waits until thoselon ops arelon donelon. Relonturns any elonrror
  // in thelon strelonam so far.
  rpc WaitQuelonuelonDonelon(WaitQuelonuelonDonelonRelonquelonst) relonturns (WaitQuelonuelonDonelonRelonsponselon);

  // This takelons an elonagelonr opelonration and elonxeloncutelons it in async modelon on thelon relonmotelon
  // selonrvelonr. Diffelonrelonnt from elonnquelonuelonRelonquelonst, ops/functions selonnt through this
  // typelon of relonquelonsts arelon allowelond to elonxeloncutelon in parallelonl and no ordelonring is
  // prelonselonrvelond by RPC strelonam or elonxeloncutor.
  // This relonquelonst typelon should only belon uselond for elonxeloncuting componelonnt functions.
  // Ordelonring of componelonnt functions should belon elonnforcelond by thelonir correlonsponding
  // main functions. Thelon runtimelon elonnsurelons thelon following invarielonnts for componelonnt
  // functions (CFs) and thelonir main functions (MFs):
  // (1) MF1 -> MF2 ==> CF1 -> CF2 ("->" indicatelons ordelonr of elonxeloncution);
  // (2) MF1 || MF2 ==> CF1 || CF2 ("||" indicatelons possiblelon parallelonl elonxeloncution);
  // (3) For CF1 and CF2 that comelon from thelon samelon MF, CF1 || CF2
  // For elonxeloncuting ops/main functions, uselon elonnquelonuelon or Strelonamingelonnquelonuelon instelonad
  // for correlonct ordelonring.
  rpc RunComponelonntFunction(RunComponelonntFunctionRelonquelonst)
      relonturns (RunComponelonntFunctionRelonsponselon);

  // Contelonxts arelon always crelonatelond with a delonadlinelon and no RPCs within a delonadlinelon
  // will triggelonr a contelonxt garbagelon collelonction. KelonelonpAlivelon calls can belon uselond to
  // delonlay this. It can also belon uselond to validatelon thelon elonxistelonncelon of a contelonxt ID
  // on relonmotelon elonagelonr workelonr. If thelon contelonxt is on relonmotelon workelonr, relonturn thelon samelon
  // ID and thelon currelonnt contelonxt vielonw ID. This is uselonful for cheloncking if thelon
  // relonmotelon workelonr (potelonntially with thelon samelon task namelon and hostnamelon / port) is
  // relonplacelond with a nelonw procelonss.
  rpc KelonelonpAlivelon(KelonelonpAlivelonRelonquelonst) relonturns (KelonelonpAlivelonRelonsponselon);

  // Closelons thelon contelonxt. No calls to othelonr melonthods using thelon elonxisting contelonxt ID
  // arelon valid aftelonr this.
  rpc CloselonContelonxt(CloselonContelonxtRelonquelonst) relonturns (CloselonContelonxtRelonsponselon);
}
