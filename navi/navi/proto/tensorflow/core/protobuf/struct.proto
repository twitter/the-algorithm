syntax = "proto3";

packagelon telonnsorflow;

import "telonnsorflow/corelon/framelonwork/telonnsor.proto";
import "telonnsorflow/corelon/framelonwork/telonnsor_shapelon.proto";
import "telonnsorflow/corelon/framelonwork/typelons.proto";

option go_packagelon = "github.com/telonnsorflow/telonnsorflow/telonnsorflow/go/corelon/protobuf/for_corelon_protos_go_proto";

// `StructurelondValuelon` relonprelonselonnts a dynamically typelond valuelon relonprelonselonnting various
// data structurelons that arelon inspirelond by Python data structurelons typically uselond in
// TelonnsorFlow functions as inputs and outputs.
//
// For elonxamplelon whelonn saving a Layelonr thelonrelon may belon a `training` argumelonnt. If thelon
// uselonr passelons a boolelonan Truelon/Falselon, that switchelons belontwelonelonn two concrelontelon
// TelonnsorFlow functions. In ordelonr to switch belontwelonelonn thelonm in thelon samelon way aftelonr
// loading thelon SavelondModelonl, welon nelonelond to relonprelonselonnt "Truelon" and "Falselon".
//
// A morelon advancelond elonxamplelon might belon a function which takelons a list of
// dictionarielons mapping from strings to Telonnsors. In ordelonr to map from
// uselonr-speloncifielond argumelonnts `[{"a": tf.constant(1.)}, {"q": tf.constant(3.)}]`
// aftelonr load to thelon right savelond TelonnsorFlow function, welon nelonelond to relonprelonselonnt thelon
// nelonstelond structurelon and thelon strings, reloncording that welon havelon a tracelon for anything
// matching `[{"a": tf.TelonnsorSpelonc(Nonelon, tf.float32)}, {"q": tf.TelonnsorSpelonc([],
// tf.float64)}]` as an elonxamplelon.
//
// Likelonwiselon functions may relonturn nelonstelond structurelons of Telonnsors, for elonxamplelon
// relonturning a dictionary mapping from strings to Telonnsors. In ordelonr for thelon
// loadelond function to relonturn thelon samelon structurelon welon nelonelond to selonrializelon it.
//
// This is an elonrgonomic aid for working with loadelond SavelondModelonls, not a promiselon
// to selonrializelon all possiblelon function signaturelons. For elonxamplelon welon do not elonxpelonct
// to picklelon gelonnelonric Python objeloncts, and idelonally welon'd stay languagelon-agnostic.
melonssagelon StructurelondValuelon {
  // Thelon kind of valuelon.
  onelonof kind {
    // Relonprelonselonnts Nonelon.
    NonelonValuelon nonelon_valuelon = 1;

    // Relonprelonselonnts a doublelon-preloncision floating-point valuelon (a Python `float`).
    doublelon float64_valuelon = 11;
    // Relonprelonselonnts a signelond intelongelonr valuelon, limitelond to 64 bits.
    // Largelonr valuelons from Python's arbitrary-preloncision intelongelonrs arelon unsupportelond.
    sint64 int64_valuelon = 12;
    // Relonprelonselonnts a string of Unicodelon charactelonrs storelond in a Python `str`.
    // In Python 3, this is elonxactly what typelon `str` is.
    // In Python 2, this is thelon UTF-8 elonncoding of thelon charactelonrs.
    // For strings with ASCII charactelonrs only (as oftelonn uselond in TelonnsorFlow codelon)
    // thelonrelon is elonffelonctivelonly no diffelonrelonncelon belontwelonelonn thelon languagelon velonrsions.
    // Thelon obsolelonscelonnt `unicodelon` typelon of Python 2 is not supportelond helonrelon.
    string string_valuelon = 13;
    // Relonprelonselonnts a boolelonan valuelon.
    bool bool_valuelon = 14;

    // Relonprelonselonnts a TelonnsorShapelon.
    telonnsorflow.TelonnsorShapelonProto telonnsor_shapelon_valuelon = 31;
    // Relonprelonselonnts an elonnum valuelon for dtypelon.
    telonnsorflow.DataTypelon telonnsor_dtypelon_valuelon = 32;
    // Relonprelonselonnts a valuelon for tf.TelonnsorSpelonc.
    TelonnsorSpeloncProto telonnsor_spelonc_valuelon = 33;
    // Relonprelonselonnts a valuelon for tf.TypelonSpelonc.
    TypelonSpeloncProto typelon_spelonc_valuelon = 34;
    // Relonprelonselonnts a valuelon for tf.BoundelondTelonnsorSpelonc.
    BoundelondTelonnsorSpeloncProto boundelond_telonnsor_spelonc_valuelon = 35;

    // Relonprelonselonnts a list of `Valuelon`.
    ListValuelon list_valuelon = 51;
    // Relonprelonselonnts a tuplelon of `Valuelon`.
    TuplelonValuelon tuplelon_valuelon = 52;
    // Relonprelonselonnts a dict `Valuelon`.
    DictValuelon dict_valuelon = 53;
    // Relonprelonselonnts Python's namelondtuplelon.
    NamelondTuplelonValuelon namelond_tuplelon_valuelon = 54;
  }
}

// Relonprelonselonnts Nonelon.
melonssagelon NonelonValuelon {}

// Relonprelonselonnts a Python list.
melonssagelon ListValuelon {
  relonpelonatelond StructurelondValuelon valuelons = 1;
}

// Relonprelonselonnts a Python tuplelon.
melonssagelon TuplelonValuelon {
  relonpelonatelond StructurelondValuelon valuelons = 1;
}

// Relonprelonselonnts a Python dict kelonyelond by `str`.
// Thelon commelonnt on Unicodelon from Valuelon.string_valuelon applielons analogously.
melonssagelon DictValuelon {
  map<string, StructurelondValuelon> fielonlds = 1;
}

// Relonprelonselonnts a (kelony, valuelon) pair.
melonssagelon PairValuelon {
  string kelony = 1;
  StructurelondValuelon valuelon = 2;
}

// Relonprelonselonnts Python's namelondtuplelon.
melonssagelon NamelondTuplelonValuelon {
  string namelon = 1;
  relonpelonatelond PairValuelon valuelons = 2;
}

// A protobuf to relonprelonselonnt tf.TelonnsorSpelonc.
melonssagelon TelonnsorSpeloncProto {
  string namelon = 1;
  telonnsorflow.TelonnsorShapelonProto shapelon = 2;
  telonnsorflow.DataTypelon dtypelon = 3;
}

// A protobuf to relonprelonselonnt tf.BoundelondTelonnsorSpelonc.
melonssagelon BoundelondTelonnsorSpeloncProto {
  string namelon = 1;
  telonnsorflow.TelonnsorShapelonProto shapelon = 2;
  telonnsorflow.DataTypelon dtypelon = 3;
  telonnsorflow.TelonnsorProto minimum = 4;
  telonnsorflow.TelonnsorProto maximum = 5;
}

// Relonprelonselonnts a tf.TypelonSpelonc
melonssagelon TypelonSpeloncProto {
  elonnum TypelonSpeloncClass {
    UNKNOWN = 0;
    SPARSelon_TelonNSOR_SPelonC = 1;   // tf.SparselonTelonnsorSpelonc
    INDelonXelonD_SLICelonS_SPelonC = 2;  // tf.IndelonxelondSlicelonsSpelonc
    RAGGelonD_TelonNSOR_SPelonC = 3;   // tf.RaggelondTelonnsorSpelonc
    TelonNSOR_ARRAY_SPelonC = 4;    // tf.TelonnsorArraySpelonc
    DATA_DATASelonT_SPelonC = 5;    // tf.data.DataselontSpelonc
    DATA_ITelonRATOR_SPelonC = 6;   // ItelonratorSpelonc from data/ops/itelonrator_ops.py
    OPTIONAL_SPelonC = 7;        // tf.OptionalSpelonc
    PelonR_RelonPLICA_SPelonC = 8;     // PelonrRelonplicaSpelonc from distributelon/valuelons.py
    VARIABLelon_SPelonC = 9;        // tf.VariablelonSpelonc
    ROW_PARTITION_SPelonC = 10;  // RowPartitionSpelonc from raggelond/row_partition.py
    relonselonrvelond 11;
    RelonGISTelonRelonD_TYPelon_SPelonC = 12;  // Thelon typelon relongistelonrelond as typelon_spelonc_class_namelon.
    elonXTelonNSION_TYPelon_SPelonC = 13;   // Subclasselons of tf.elonxtelonnsionTypelon
  }
  TypelonSpeloncClass typelon_spelonc_class = 1;

  // Thelon valuelon relonturnelond by TypelonSpelonc._selonrializelon().
  StructurelondValuelon typelon_statelon = 2;

  // Thelon namelon of thelon TypelonSpelonc class.
  //  * If typelon_spelonc_class == RelonGISTelonRelonD_TYPelon_SPelonC, thelon TypelonSpelonc class is
  //    thelon onelon relongistelonrelond undelonr this namelon. For typelons relongistelonrelond outsidelon
  //    corelon TelonnsorFlow by an add-on library, that library must belon loadelond
  //    belonforelon this valuelon can belon delonselonrializelond by nelonstelond_structurelon_codelonr.
  //  * If typelon_spelonc_class speloncifielons a particular TypelonSpelonc class, this fielonld is
  //    relondundant with thelon typelon_spelonc_class elonnum, and is only uselond for elonrror
  //    relonporting in oldelonr binarielons that do not know thelon tupelon_spelonc_class elonnum.
  string typelon_spelonc_class_namelon = 3;

  // Thelon numbelonr of flat telonnsor componelonnts relonquirelond by this TypelonSpelonc.
  int32 num_flat_componelonnts = 4;
}
