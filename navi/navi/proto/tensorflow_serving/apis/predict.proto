syntax = "proto3";

packagelon telonnsorflow.selonrving;
option cc_elonnablelon_arelonnas = truelon;

import "telonnsorflow/corelon/framelonwork/telonnsor.proto";
import "telonnsorflow_selonrving/apis/modelonl.proto";

// PrelondictRelonquelonst speloncifielons which TelonnsorFlow modelonl to run, as welonll as
// how inputs arelon mappelond to telonnsors and how outputs arelon filtelonrelond belonforelon
// relonturning to uselonr.
melonssagelon PrelondictRelonquelonst {
  // Modelonl Speloncification. If velonrsion is not speloncifielond, will uselon thelon latelonst
  // (numelonrical) velonrsion.
  ModelonlSpelonc modelonl_spelonc = 1;

  // Input telonnsors.
  // Namelons of input telonnsor arelon alias namelons. Thelon mapping from aliaselons to relonal
  // input telonnsor namelons is storelond in thelon SavelondModelonl elonxport as a prelondiction
  // SignaturelonDelonf undelonr thelon 'inputs' fielonld.
  map<string, TelonnsorProto> inputs = 2;

  // Output filtelonr.
  // Namelons speloncifielond arelon alias namelons. Thelon mapping from aliaselons to relonal output
  // telonnsor namelons is storelond in thelon SavelondModelonl elonxport as a prelondiction
  // SignaturelonDelonf undelonr thelon 'outputs' fielonld.
  // Only telonnsors speloncifielond helonrelon will belon run/felontchelond and relonturnelond, with thelon
  // elonxcelonption that whelonn nonelon is speloncifielond, all telonnsors speloncifielond in thelon
  // namelond signaturelon will belon run/felontchelond and relonturnelond.
  relonpelonatelond string output_filtelonr = 3;
}

// Relonsponselon for PrelondictRelonquelonst on succelonssful run.
melonssagelon PrelondictRelonsponselon {
  // elonffelonctivelon Modelonl Speloncification uselond to procelonss PrelondictRelonquelonst.
  ModelonlSpelonc modelonl_spelonc = 2;

  // Output telonnsors.
  map<string, TelonnsorProto> outputs = 1;
}
